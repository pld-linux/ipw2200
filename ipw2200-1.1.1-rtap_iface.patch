Enable rtap interface for RF promiscuous mode while associated

With this patch, a new promiscuous mode is enabled.  Once applied, 
when you load the module with the rtap_iface=1 module parameter, two 
interfaces will be created (instead of just one). 

The second interface is prefixed 'rtap' and provides received 
802.11 frames on the current channel to user space in a radiotap header 
format.

Example usage:

	% modprobe ipw2200 rtap_iface=1
	% iwconfig eth1 essid MyNetwork
	% dhcpcd eth1
	% tcpdump -i rtap0

If you do not specify 'rtap_iface=1' then the rtap interface will 
not be created and you will need to turn it on via:
	
	% echo 1 > /sys/bus/pci/drivers/ipw2200/*/rtap_iface

You can filter out what type of information is passed to user space via 
the rtap_filter sysfs entry.  Currently you can tell the driver to 
transmit just the headers (which will provide the RADIOTAP and IEEE 
802.11 header but not the payload), to filter based on frame control 
type (Management, Control, or Data), and whether to report transmitted 
frames, received frames, or both.

The transmit frame reporting is based on a patch by Stefan Rompf.

Example usage:

First, see what filter bits are available:

	% ./filters

Now set the filter to only send headers (0x7), don't report Tx'd frames 
(0x10), and don't report data frames (0x100):

	% echo 0x117 > /sys/bus/pci/drivers/ipw2200/*/rtap_filter

All your packets are belong to us:

	% tethereal -n -i rtap0

As a side note, you can see a sample user space application to pull the 
packets in user space in the file ipwstats.c.  Check the start of that 
file for information on building and running that utility.

Signed-off-by: James Ketrenos <jketreno@linux.intel.com>

---
 Makefile                |   24 +
 filters                 |   56 +++
 in-tree/Kconfig.ipw2200 |   83 +++++
 ipw2200.c               |  661 ++++++++++++++++++++++++++++++++++++++++--
 ipw2200.h               |   83 +++++
 ipwstats.c              |  752 ++++++++++++++++++++++++++++++++++++++++++++++++
 ipwstats.cc             |  571 ++++++++++++++++++++++++++++++++++++
 7 files changed, 2192 insertions(+), 38 deletions(-)
diff -Nupr ipw2200-1.1.1/Makefile ipw2200-1.1.1-rtap/Makefile
--- ipw2200-1.1.1/Makefile	2006-03-08 06:42:54.000000000 -0600
+++ ipw2200-1.1.1-rtap/Makefile	2006-03-23 15:07:00.000000000 -0600
@@ -28,7 +28,16 @@ CONFIG_IPW2200_MONITOR=y
 
 # If you are interested in using radiotap headers in monitor mode,
 # simply uncomment:
-#CONFIG_IEEE80211_RADIOTAP=y
+#
+# NOTE:  To use RADIOTAP you must also enable MONITOR above.
+CONFIG_IEEE80211_RADIOTAP=y
+
+# The above monitor mode provides standard monitor mode.  The following
+# will create a new interface (named rtap%d) which will be sent all
+# 802.11 frames received on the interface
+#
+# NOTE:  To use PROMISCUOUS you must also enable MONITOR above.
+CONFIG_IPW2200_PROMISCUOUS=y
 
 endif
 
@@ -83,6 +92,9 @@ EXTRA_CFLAGS += -DCONFIG_IPW2200_MONITOR
 ifdef CONFIG_IEEE80211_RADIOTAP
 EXTRA_CFLAGS += -DCONFIG_IEEE80211_RADIOTAP=$(CONFIG_IEEE80211_RADIOTAP)
 endif
+ifdef CONFIG_IPW2200_PROMISCUOUS
+EXTRA_CFLAGS += -DCONFIG_IPW2200_PROMISCUOUS=$(CONFIG_IPW2200_PROMISCUOUS)
+endif
 endif
 ifdef CONFIG_IPW_QOS
 EXTRA_CFLAGS += -DCONFIG_IPW_QOS=$(CONFIG_IPW_QOS)
@@ -132,7 +144,7 @@ check_inc:
 	@[ -e $(IEEE80211_INC)/net/ieee80211.h ]
 
 clean:
-	rm -f *.mod.c *.mod *.o *.ko .*.cmd .*.flags .lst *.lst
+	rm -f *.mod.c *.mod *.o *.ko .*.cmd .*.flags .lst *.lst ipwstats
 	rm -rf $(PWD)/tmp
 	for file in *.{c,h}; do \
 		sed -i -e "s:\ *$$::g" -e "s:\t*$$::g" $$file; \
@@ -184,6 +196,7 @@ patch_kernel:
 "obj-\$$(CONFIG_IPW2200)         += ipw2200.o" >> \
 		${KSRC}/drivers/net/wireless/Makefile)
 	@cp README.ipw2200 ${KSRC}/Documentation/networking
+	@cp ipw2200.{c,h} ${KSRC}/drivers/net/wireless
 	@cp in-tree/Kconfig.ipw2200 ${KSRC}/drivers/net/wireless
 	@(grep -q "Kconfig\.ipw2200" ${KSRC}/drivers/net/wireless/Kconfig || \
 	grep -q "IPW2200" ${KSRC}/drivers/net/wireless/Kconfig || \
@@ -205,7 +218,7 @@ uninstall:
 endif # End of internal build
 
 
-.PHONY: TAGS tags check_inc
+.PHONY: TAGS tags check_inc apps
 
 RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o -name CVS \) -prune -o
 define all-sources
@@ -219,3 +232,8 @@ tags:
 	CTAGSF=`ctags --version | grep -i exuberant >/dev/null && echo "-I __initdata,__exitdata,EXPORT_SYMBOL,EXPORT_SYMBOL_NOVERS"`; \
 	$(all-sources) | xargs ctags $$CTAGSF -a
 
+apps : ipwstats
+
+ipwstats : ipwstats.c
+	gcc -Wall -I/usr/src/linux/include/ -o $@ $^ $$(pkg-config gtk+-2.0 --cflags --libs)
+
diff -Nupr ipw2200-1.1.1/filters ipw2200-1.1.1-rtap/filters
--- ipw2200-1.1.1/filters	1969-12-31 18:00:00.000000000 -0600
+++ ipw2200-1.1.1-rtap/filters	2006-03-22 15:01:37.000000000 -0600
@@ -0,0 +1,56 @@
+#!/bin/sh
+MODULE="ipw2200"
+FILTER_PATH="/sys/bus/pci/drivers/${MODULE}/*/rtap_filter"
+LEVEL=""
+
+function get_level()
+{
+	if [ ! -e ${FILTER_PATH} ]; then
+		LEVEL=""
+	else
+		LEVEL=`cat ${FILTER_PATH}`
+	fi
+}
+
+function bit()
+{
+	VAL=1
+	for ((i = 0; i < $2; i++)); do
+		VAL=$((VAL*2))
+	done
+	SET="$((VAL & $3))"
+	if [ "${SET}" = "0" ]; then
+		SET=" "
+	else
+		SET="*"
+	fi
+	printf "%-20s\t\t0x%08X [%s] %d\n" $1 $VAL "$SET" $VAL
+}
+
+IFS="
+"
+LEVELS=$(sed -ne "s#.*IPW_PROM_\(.*\)[ \t]*=[ \t]*(1[ \t]*<<[ \t]*\(.*\)).*#\1 \2#p" ipw2200.h)
+get_level
+
+if [ ! -z ${LEVEL} ]; then
+	LEV=$((LEVEL))
+else
+	LEV=0
+fi
+printf "%-20s\t\t%-10s Set Decimal\n" "Description" "Hex"
+for i in $LEVELS; do
+	IFS=" 
+"
+	bit $i ${LEV}
+done
+
+if [ ! -z ${LEVEL} ]; then
+	printf "rtap_filter = ${LEVEL} (* = enabled)\n"
+else
+	printf "${MODULE} not currently loaded.  rtap_filter not set.\n"
+fi
+cat << EOF
+Example usage:
+  \$((0x1 + 0x2 + 0x4 ...)) > /sys/bus/pci/drivers/ipw2200/*/rtap_filter
+EOF
+
diff -Nupr ipw2200-1.1.1/in-tree/Kconfig.ipw2200 ipw2200-1.1.1-rtap/in-tree/Kconfig.ipw2200
--- ipw2200-1.1.1/in-tree/Kconfig.ipw2200	1969-12-31 18:00:00.000000000 -0600
+++ ipw2200-1.1.1-rtap/in-tree/Kconfig.ipw2200	2006-03-21 09:19:58.000000000 -0600
@@ -0,0 +1,83 @@
+config IPW2200
+	tristate "Intel PRO/Wireless 2200BG and 2915ABG Network Connection"
+	depends on IEEE80211 && PCI && NET_RADIO
+	select FW_LOADER
+	---help---
+          A driver for the Intel PRO/Wireless 2200BG and 2915ABG Network
+	  Connection adapters. 
+
+          See <file:Documentation/networking/README.ipw2200> for 
+	  information on the capabilities currently enabled in this 
+	  driver and for tips for debugging issues and problems.
+
+	  In order to use this driver, you will need a firmware image for it.
+          You can obtain the firmware from
+	  <http://ipw2200.sf.net/>.  See the above referenced README.ipw2200 
+	  for information on where to install the firmare images.
+
+          You will also very likely need the Wireless Tools in order to
+          configure your card:
+
+          <http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html>.
+ 
+          If you want to compile the driver as a module ( = code which can be
+          inserted in and remvoed from the running kernel whenever you want),
+          say M here and read <file:Documentation/modules.txt>.  The module
+          will be called ipw2200.ko.
+
+config IPW2200_DEBUG
+	bool "Enable full debugging output in IPW2200 module."
+	depends on IPW2200
+	---help---
+	  This option will enable debug tracing output for the IPW2200.  
+
+	  This will result in the kernel module being ~100k larger.  You can 
+	  control which debug output is sent to the kernel log by setting the 
+	  value in 
+
+	  /sys/bus/pci/drivers/ipw2200/debug_level
+
+	  This entry will only exist if this option is enabled.
+
+	  To set a value, simply echo an 8-byte hex value to the same file:
+
+	  % echo 0x00000FFO > /sys/bus/pci/drivers/ipw2200/debug_level
+
+	  You can find the list of debug mask values in 
+	  drivers/net/wireless/ipw2200.h
+
+	  If you are not trying to debug or develop the IPW2200 driver, you 
+	  most likely want to say N here.
+
+config IPW2200_MONITOR
+        bool "Enable RF monitor mode"
+        depends on IPW2200
+        ---help---
+	  Enables monitor (aka promiscuous) mode support for the ipw2200 
+	  driver.  With this feature compiled into the driver, you can 
+	  switch to monitor mode via the Wireless Tool's mode command.
+	  While in monitor mode, no packets can be sent.
+
+config IPW2200_PROMISCUOUS
+	bool "Enable creation of a RF radiotap promiscuous interface."
+	depends on IPW2200
+	select IEEE80211_RADIOTAP
+	---help---
+          Enables the creation of a second interface prefixed 'rtap'. 
+          This second interface will provide every received in radiotap
+	  format.
+
+          This is useful for performing wireless network analysis while
+          maintaining an active association.
+
+          Example usage:
+
+            % modprobe ipw2200 rtap_iface=1
+            % ifconfig rtap0 up
+            % tethereal -i rtap0
+
+          If you do not specify 'rtap_iface=1' as a module parameter then 
+          the rtap interface will not be created and you will need to turn 
+          it on via sysfs:
+	
+            % echo 1 > /sys/bus/pci/drivers/ipw2200/*/rtap_iface
diff -Nupr ipw2200-1.1.1/ipw2200.c ipw2200-1.1.1-rtap/ipw2200.c
--- ipw2200-1.1.1/ipw2200.c	2006-03-08 06:42:55.000000000 -0600
+++ ipw2200-1.1.1-rtap/ipw2200.c	2006-03-23 17:27:14.000000000 -0600
@@ -33,7 +33,38 @@
 #include "ipw2200.h"
 #include <linux/version.h>
 
-#define IPW2200_VERSION "1.1.1"
+
+#ifdef CONFIG_IPW2200_DEBUG
+#define VD "d"
+#else
+#define VD
+#endif
+
+#ifdef CONFIG_IPW2200_MONITOR
+#define VM "m"
+#else
+#define VM
+#endif
+
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+#define VP "p"
+#else
+#define VP
+#endif
+
+#ifdef CONFIG_IEEE80211_RADIOTAP
+#define VR "r"
+#else
+#define VR
+#endif
+
+#ifdef CONFIG_IPW2200_QOS
+#define VQ "q"
+#else
+#define VQ
+#endif
+
+#define IPW2200_VERSION "1.1.1k" VD VM VP VR VQ
 #define DRV_DESCRIPTION	"Intel(R) PRO/Wireless 2200/2915 Network Driver"
 #define DRV_COPYRIGHT	"Copyright(c) 2003-2006 Intel Corporation"
 #define DRV_VERSION     IPW2200_VERSION
@@ -46,7 +77,9 @@ MODULE_AUTHOR(DRV_COPYRIGHT);
 MODULE_LICENSE("GPL");
 
 static int cmdlog = 0;
+#ifdef CONFIG_IPW2200_DEBUG
 static int debug = 0;
+#endif
 static int channel = 0;
 static int mode = 0;
 
@@ -62,6 +95,11 @@ static const char ipw_modes[] = {
 	'a', 'b', 'g', '?'
 };
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+static int rtap_iface = 0;     /* def: 0 -- do not create rtap interface */
+#endif
+
+
 #ifdef CONFIG_IPW_QOS
 static int qos_enable = 0;
 static int qos_burst_enable = 0;
@@ -1286,6 +1324,113 @@ static ssize_t show_cmd_log(struct devic
 
 static DEVICE_ATTR(cmd_log, S_IRUGO, show_cmd_log, NULL);
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+static void ipw_prom_free(struct ipw_priv *priv);
+static int ipw_prom_alloc(struct ipw_priv *priv);
+static ssize_t store_rtap_iface(struct device *d,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+			 struct device_attribute *attr,
+#endif
+			 const char *buf, size_t count)
+{
+	struct ipw_priv *priv = dev_get_drvdata(d);
+	int rc = 0;
+
+	if (count < 1)
+		return -EINVAL;
+
+	switch (buf[0]) {
+	case '0':
+		if (!rtap_iface)
+			return count;
+
+		if (netif_running(priv->prom_net_dev)) {
+			IPW_WARNING("Interface is up.  Cannot unregister.\n");
+			return count;
+		}
+
+		ipw_prom_free(priv);
+		rtap_iface = 0;
+		break;
+
+	case '1':
+		if (rtap_iface)
+			return count;
+
+		rc = ipw_prom_alloc(priv);
+		if (!rc)
+			rtap_iface = 1;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	if (rc) {
+		IPW_ERROR("Failed to register promiscuous network "
+			  "device (error %d).\n", rc);
+	}
+
+	return count;
+}
+
+static ssize_t show_rtap_iface(struct device *d,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+			struct device_attribute *attr,
+#endif
+			char *buf)
+{
+	struct ipw_priv *priv = dev_get_drvdata(d);
+	if (rtap_iface)
+		return sprintf(buf, "%s", priv->prom_net_dev->name);
+	else {
+		buf[0] = '-';
+		buf[1] = '1';
+		buf[2] = '\0';
+		return 3;
+	}
+}
+
+static DEVICE_ATTR(rtap_iface, S_IWUSR | S_IRUSR, show_rtap_iface,
+		   store_rtap_iface);
+
+static ssize_t store_rtap_filter(struct device *d,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+			 struct device_attribute *attr,
+#endif
+			 const char *buf, size_t count)
+{
+	struct ipw_priv *priv = dev_get_drvdata(d);
+
+	if (!priv->prom_priv) {
+		IPW_ERROR("Attempting to set filter without "
+			  "rtap_iface enabled.\n");
+		return -EPERM;
+	}
+
+	priv->prom_priv->filter = simple_strtol(buf, NULL, 0);
+
+	IPW_DEBUG_INFO("Setting rtap filter to " BIT_FMT16 "\n",
+		       BIT_ARG16(priv->prom_priv->filter));
+
+	return count;
+}
+
+static ssize_t show_rtap_filter(struct device *d,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+			struct device_attribute *attr,
+#endif
+			char *buf)
+{
+	struct ipw_priv *priv = dev_get_drvdata(d);
+	return sprintf(buf, "0x%04X",
+		       priv->prom_priv ? priv->prom_priv->filter : 0);
+}
+
+static DEVICE_ATTR(rtap_filter, S_IWUSR | S_IRUSR, show_rtap_filter,
+		   store_rtap_filter);
+#endif
+
 static ssize_t show_scan_age(struct device *d,
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
 			     struct device_attribute *attr,
@@ -2117,16 +2262,11 @@ static int ipw_send_host_complete(struct
 	return ipw_send_cmd_simple(priv, IPW_CMD_HOST_COMPLETE);
 }
 
-static int ipw_send_system_config(struct ipw_priv *priv,
-				  struct ipw_sys_config *config)
+static int ipw_send_system_config(struct ipw_priv *priv)
 {
-	if (!priv || !config) {
-		IPW_ERROR("Invalid args\n");
-		return -1;
-	}
-
-	return ipw_send_cmd_pdu(priv, IPW_CMD_SYSTEM_CONFIG, sizeof(*config),
-				config);
+	return ipw_send_cmd_pdu(priv, IPW_CMD_SYSTEM_CONFIG,
+				sizeof(priv->sys_config),
+				&priv->sys_config);
 }
 
 static int ipw_send_ssid(struct ipw_priv *priv, u8 * ssid, int len)
@@ -3592,7 +3732,8 @@ static int ipw_queue_tx_init(struct ipw_
  * @param txq
  */
 static void ipw_queue_tx_free_tfd(struct ipw_priv *priv,
-				  struct clx2_tx_queue *txq)
+				  struct clx2_tx_queue *txq,
+				  int count)
 {
 	struct tfd_frame *bd = &txq->bd[txq->q.last_used];
 	struct pci_dev *dev = priv->pci_dev;
@@ -3617,6 +3758,12 @@ static void ipw_queue_tx_free_tfd(struct
 				 le16_to_cpu(bd->u.data.chunk_len[i]),
 				 PCI_DMA_TODEVICE);
 		if (txq->txb[txq->q.last_used]) {
+			struct sk_buff *skb = txq->txb[txq->q.last_used]->
+				fragments[0];
+			struct ieee80211_hdr *hdr = (void *)skb->data;
+			priv->tx_bytes += skb->len -
+				ieee80211_get_hdrlen(hdr->frame_ctl);
+			priv->tx_packets++;
 			ieee80211_txb_free(txq->txb[txq->q.last_used]);
 			txq->txb[txq->q.last_used] = NULL;
 		}
@@ -3643,7 +3790,7 @@ static void ipw_queue_tx_free(struct ipw
 	/* first, empty all BD's */
 	for (; q->first_empty != q->last_used;
 	     q->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {
-		ipw_queue_tx_free_tfd(priv, txq);
+		ipw_queue_tx_free_tfd(priv, txq, 0);
 	}
 
 	/* free buffers belonging to queue itself */
@@ -3787,7 +3934,17 @@ static void ipw_bg_disassociate(void *da
 static void ipw_system_config(void *data)
 {
 	struct ipw_priv *priv = data;
-	ipw_send_system_config(priv, &priv->sys_config);
+
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	if (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {
+		priv->sys_config.accept_all_data_frames = 1;
+		priv->sys_config.accept_non_directed_frames = 1;
+		priv->sys_config.accept_all_mgmt_bcpr = 1;
+		priv->sys_config.accept_all_mgmt_frames = 1;
+	}
+#endif
+
+	ipw_send_system_config(priv);
 }
 
 struct ipw_status_code {
@@ -4778,8 +4935,7 @@ static int ipw_queue_tx_reclaim(struct i
 	}
 	for (; q->last_used != hw_tail;
 	     q->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {
-		ipw_queue_tx_free_tfd(priv, txq);
-		priv->tx_packets++;
+		ipw_queue_tx_free_tfd(priv, txq, 1);
 	}
       done:
 	if ((ipw_queue_space(q) > q->low_mark) &&
@@ -7686,7 +7842,7 @@ static int ipw_associate_network(struct 
 	else
 		priv->sys_config.answer_broadcast_ssid_probe = 0;
 
-	err = ipw_send_system_config(priv, &priv->sys_config);
+	err = ipw_send_system_config(priv);
 	if (err) {
 		IPW_DEBUG_HC("Attempt to send sys config command failed.\n");
 		return err;
@@ -7976,12 +8132,14 @@ static void ipw_handle_data_packet(struc
 	IPW_DEBUG_RX("Rx packet of %d bytes.\n", rxb->skb->len);
 
 	/* HW decrypt will not clear the WEP bit, MIC, PN, etc. */
-	hdr = (struct ieee80211_hdr_4addr *)rxb->skb->data;
+	hdr = (void *)rxb->skb->data;
 	if (priv->ieee->iw_mode != IW_MODE_MONITOR &&
 	    (ipw_is_multicast_ether_addr(hdr->addr1) ?
 	     !priv->ieee->host_mc_decrypt : !priv->ieee->host_decrypt))
 		ipw_rebuild_decrypted_skb(priv, rxb->skb);
 
+	priv->rx_bytes += rxb->skb->len - ieee80211_get_hdrlen(hdr->frame_ctl);
+
 	if (!ieee80211_rx(priv->ieee, rxb->skb, stats))
 		priv->ieee->stats.rx_errors++;
 	else {			/* ieee80211_rx succeeded, so it now owns the SKB */
@@ -8007,15 +8165,7 @@ static void ipw_handle_data_packet_monit
 	/* Magic struct that slots into the radiotap header -- no reason
 	 * to build this manually element by element, we can write it much
 	 * more efficiently than we can parse it. ORDER MATTERS HERE */
-	struct ipw_rt_hdr {
-		struct ieee80211_radiotap_header rt_hdr;
-		u8 rt_flags;	/* radiotap packet flags */
-		u8 rt_rate;	/* rate in 500kb/s */
-		u16 rt_channel;	/* channel in mhz */
-		u16 rt_chbitmask;	/* channel bitfield */
-		s8 rt_dbmsignal;	/* signal in dbM, kluged to signed */
-		u8 rt_antenna;	/* antenna number */
-	} *ipw_rt;
+	struct ipw_rt_hdr *ipw_rt;
 
 	short len = le16_to_cpu(pkt->u.frame.length);
 
@@ -8069,9 +8219,11 @@ static void ipw_handle_data_packet_monit
 	/* Big bitfield of all the fields we provide in radiotap */
 	ipw_rt->rt_hdr.it_present =
 	    ((1 << IEEE80211_RADIOTAP_FLAGS) |
+	     (1 << IEEE80211_RADIOTAP_TSFT) |
 	     (1 << IEEE80211_RADIOTAP_RATE) |
 	     (1 << IEEE80211_RADIOTAP_CHANNEL) |
 	     (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |
+	     (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |
 	     (1 << IEEE80211_RADIOTAP_ANTENNA));
 
 	/* Zero the flags, we'll add to them as we go */
@@ -8157,6 +8309,220 @@ static void ipw_handle_data_packet_monit
 }
 #endif
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+#define ieee80211_is_probe_response(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT && \
+    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PROBE_RESP )
+
+#define ieee80211_is_management(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT)
+
+#define ieee80211_is_control(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL)
+
+#define ieee80211_is_data(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA)
+
+#define ieee80211_is_assoc_request(fc) \
+   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_ASSOC_REQ)
+
+#define ieee80211_is_reassoc_request(fc) \
+   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_REASSOC_REQ)
+
+static void ipw_handle_promiscuous_rx(struct ipw_priv *priv,
+				      struct ipw_rx_mem_buffer *rxb,
+				      struct ieee80211_rx_stats *stats)
+{
+	struct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;
+	struct ipw_rx_frame *frame = &pkt->u.frame;
+	struct ipw_rt_hdr *ipw_rt;
+
+	/* First cache any information we need before we overwrite
+	 * the information provided in the skb from the hardware */
+	struct ieee80211_hdr *hdr;
+	u16 channel = frame->received_channel;
+	u8 phy_flags = frame->antennaAndPhy;
+	s8 signal = frame->rssi_dbm - IPW_RSSI_TO_DBM;
+	s8 noise = frame->noise;
+	u8 rate = frame->rate;
+	short len = le16_to_cpu(pkt->u.frame.length);
+	u64 tsf = 0;
+	struct sk_buff *skb;
+	int hdr_only = 0;
+	u16 filter = priv->prom_priv->filter;
+
+	/* If the filter is set to not include Rx frames then return */
+	if (filter & IPW_PROM_NO_RX)
+		return;
+
+	if (!noise)
+		noise = priv->last_noise;
+
+	/* We received data from the HW, so stop the watchdog */
+	priv->prom_net_dev->trans_start = jiffies;
+
+	if (unlikely((len + IPW_RX_FRAME_SIZE) > skb_tailroom(rxb->skb))) {
+		priv->prom_priv->ieee->stats.rx_errors++;
+		IPW_DEBUG_DROP("Corruption detected! Oh no!\n");
+		return;
+	}
+
+	/* We only process data packets if the interface is open */
+	if (unlikely(!netif_running(priv->prom_net_dev))) {
+		priv->prom_priv->ieee->stats.rx_dropped++;
+		IPW_DEBUG_DROP("Dropping packet while interface is not up.\n");
+		return;
+	}
+
+	/* Libpcap 0.9.3+ can handle variable length radiotap, so we'll use
+	 * that now */
+	if (len > IPW_RX_BUF_SIZE - sizeof(struct ipw_rt_hdr)) {
+		/* FIXME: Should alloc bigger skb instead */
+		priv->prom_priv->ieee->stats.rx_dropped++;
+		IPW_DEBUG_DROP("Dropping too large packet in monitor\n");
+		return;
+	}
+
+	hdr = (void *)rxb->skb->data + IPW_RX_FRAME_SIZE;
+	if (ieee80211_is_management(hdr->frame_ctl)) {
+		if (filter & IPW_PROM_NO_MGMT)
+			return;
+		if (filter & IPW_PROM_MGMT_HEADER_ONLY)
+			hdr_only = 1;
+	} else if (ieee80211_is_control(hdr->frame_ctl)) {
+		if (filter & IPW_PROM_NO_CTL)
+			return;
+		if (filter & IPW_PROM_CTL_HEADER_ONLY)
+			hdr_only = 1;
+	} else if (ieee80211_is_data(hdr->frame_ctl)) {
+		if (filter & IPW_PROM_NO_DATA)
+			return;
+		if (filter & IPW_PROM_DATA_HEADER_ONLY)
+			hdr_only = 1;
+	}
+
+	/* Copy the SKB since this is for the promiscuous side */
+	skb = skb_copy(rxb->skb, GFP_ATOMIC);
+	if (skb == NULL) {
+		IPW_ERROR("skb_clone failed for promiscuous copy.\n");
+		return;
+	}
+
+	/* copy the frame data to write after where the radiotap header goes */
+	ipw_rt = (void *)skb->data;
+
+	if (hdr_only)
+		len = ieee80211_get_hdrlen(hdr->frame_ctl);
+
+	memcpy(ipw_rt->payload, hdr, len);
+
+	/* Zero the radiotap static buffer  ...  We only need to zero the bytes
+	 * NOT part of our real header, saves a little time.
+	 *
+	 * No longer necessary since we fill in all our data.  Purge before
+	 * merging patch officially.
+	 * memset(rxb->skb->data + sizeof(struct ipw_rt_hdr), 0,
+	 *        IEEE80211_RADIOTAP_HDRLEN - sizeof(struct ipw_rt_hdr));
+	 */
+
+	ipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;
+	ipw_rt->rt_hdr.it_pad = 0;	/* always good to zero */
+	ipw_rt->rt_hdr.it_len = sizeof(*ipw_rt);	/* total header+data */
+
+	/* Set the size of the skb to the size of the frame */
+	skb_put(skb, ipw_rt->rt_hdr.it_len + len);
+
+	/* Big bitfield of all the fields we provide in radiotap */
+	ipw_rt->rt_hdr.it_present =
+	    ((1 << IEEE80211_RADIOTAP_FLAGS) |
+	     (1 << IEEE80211_RADIOTAP_TSFT) |
+	     (1 << IEEE80211_RADIOTAP_RATE) |
+	     (1 << IEEE80211_RADIOTAP_CHANNEL) |
+	     (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |
+	     (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |
+	     (1 << IEEE80211_RADIOTAP_ANTENNA));
+
+	/* Zero the flags, we'll add to them as we go */
+	ipw_rt->rt_flags = 0;
+
+	ipw_rt->rt_tsf = tsf;
+
+	/* Convert to DBM */
+	ipw_rt->rt_dbmsignal = signal;
+	ipw_rt->rt_dbmnoise = noise;
+
+	/* Convert the channel data and set the flags */
+	ipw_rt->rt_channel = cpu_to_le16(ieee80211chan2mhz(channel));
+	if (channel > 14) {	/* 802.11a */
+		ipw_rt->rt_chbitmask =
+		    cpu_to_le16((IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ));
+	} else if (phy_flags & (1 << 5)) {	/* 802.11b */
+		ipw_rt->rt_chbitmask =
+		    cpu_to_le16((IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ));
+	} else {		/* 802.11g */
+		ipw_rt->rt_chbitmask =
+		    (IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ);
+	}
+
+	/* set the rate in multiples of 500k/s */
+	switch (rate) {
+	case IPW_TX_RATE_1MB:
+		ipw_rt->rt_rate = 2;
+		break;
+	case IPW_TX_RATE_2MB:
+		ipw_rt->rt_rate = 4;
+		break;
+	case IPW_TX_RATE_5MB:
+		ipw_rt->rt_rate = 10;
+		break;
+	case IPW_TX_RATE_6MB:
+		ipw_rt->rt_rate = 12;
+		break;
+	case IPW_TX_RATE_9MB:
+		ipw_rt->rt_rate = 18;
+		break;
+	case IPW_TX_RATE_11MB:
+		ipw_rt->rt_rate = 22;
+		break;
+	case IPW_TX_RATE_12MB:
+		ipw_rt->rt_rate = 24;
+		break;
+	case IPW_TX_RATE_18MB:
+		ipw_rt->rt_rate = 36;
+		break;
+	case IPW_TX_RATE_24MB:
+		ipw_rt->rt_rate = 48;
+		break;
+	case IPW_TX_RATE_36MB:
+		ipw_rt->rt_rate = 72;
+		break;
+	case IPW_TX_RATE_48MB:
+		ipw_rt->rt_rate = 96;
+		break;
+	case IPW_TX_RATE_54MB:
+		ipw_rt->rt_rate = 108;
+		break;
+	default:
+		ipw_rt->rt_rate = 0;
+		break;
+	}
+
+	/* antenna number */
+	ipw_rt->rt_antenna = (phy_flags & 3);
+
+	/* set the preamble flag if we have it */
+	if (phy_flags & (1 << 6))
+		ipw_rt->rt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
+
+	IPW_DEBUG_RX("Rx packet of %d bytes.\n", skb->len);
+
+	if (!ieee80211_rx(priv->prom_priv->ieee, skb, stats)) {
+		priv->prom_priv->ieee->stats.rx_errors++;
+		dev_kfree_skb_any(skb);
+	}
+}
+#endif
+
 static int is_network_packet(struct ipw_priv *priv,
 			     struct ieee80211_hdr_4addr *header)
 {
@@ -8383,15 +8749,21 @@ static void ipw_rx(struct ipw_priv *priv
 
 				priv->rx_packets++;
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	if (priv->prom_net_dev && netif_running(priv->prom_net_dev))
+		ipw_handle_promiscuous_rx(priv, rxb, &stats);
+#endif
+
 #ifdef CONFIG_IPW2200_MONITOR
 				if (priv->ieee->iw_mode == IW_MODE_MONITOR) {
 #ifdef CONFIG_IEEE80211_RADIOTAP
-					ipw_handle_data_packet_monitor(priv,
-								       rxb,
-								       &stats);
+
+                ipw_handle_data_packet_monitor(priv,
+					       rxb,
+					       &stats);
 #else
-					ipw_handle_data_packet(priv, rxb,
-							       &stats);
+		ipw_handle_data_packet(priv, rxb,
+				       &stats);
 #endif
 					break;
 				}
@@ -10443,6 +10815,86 @@ static int ipw_net_is_queue_full(struct 
 	return 0;
 }
 
+static void ipw_handle_promiscuous_tx(struct ipw_priv *priv,
+				      struct ieee80211_txb *txb) {
+	struct ieee80211_rx_stats dummystats;
+	struct ieee80211_hdr *hdr;
+	u8 n;
+	u16 filter = priv->prom_priv->filter;
+	int hdr_only = 0;
+
+	if (filter & IPW_PROM_NO_TX)
+		return;
+
+	memset(&dummystats, 0, sizeof(dummystats));
+
+	/* Filtering of fragment chains is done agains the first fragment */
+	hdr = (void *)txb->fragments[0]->data;
+	if (ieee80211_is_management(hdr->frame_ctl)) {
+		if (filter & IPW_PROM_NO_MGMT)
+			return;
+		if (filter & IPW_PROM_MGMT_HEADER_ONLY)
+			hdr_only = 1;
+	} else if (ieee80211_is_control(hdr->frame_ctl)) {
+		if (filter & IPW_PROM_NO_CTL)
+			return;
+		if (filter & IPW_PROM_CTL_HEADER_ONLY)
+			hdr_only = 1;
+	} else if (ieee80211_is_data(hdr->frame_ctl)) {
+		if (filter & IPW_PROM_NO_DATA)
+			return;
+		if (filter & IPW_PROM_DATA_HEADER_ONLY)
+			hdr_only = 1;
+	}
+
+	for(n=0; n<txb->nr_frags; ++n) {
+		struct sk_buff *src = txb->fragments[n];
+		struct sk_buff *dst;
+		struct ieee80211_radiotap_header *rt_hdr;
+		int len;
+
+		if (hdr_only) {
+			hdr = (void *)src->data;
+			len = ieee80211_get_hdrlen(hdr->frame_ctl);
+		} else
+			len = src->len;
+
+		dst = alloc_skb(
+			len + IEEE80211_RADIOTAP_HDRLEN, GFP_ATOMIC);
+		if (!dst) continue;
+
+		rt_hdr = (void *)skb_put(dst, sizeof(*rt_hdr));
+
+		rt_hdr->it_version = PKTHDR_RADIOTAP_VERSION;
+		rt_hdr->it_pad = 0;
+		rt_hdr->it_present = 0; /* after all, it's just an idea */
+		rt_hdr->it_present |=  (1 << IEEE80211_RADIOTAP_CHANNEL);
+
+		*(u16*)skb_put(dst, sizeof(u16)) = cpu_to_le16(
+			ieee80211chan2mhz(priv->channel));
+		if (priv->channel > 14) 	/* 802.11a */
+			*(u16*)skb_put(dst, sizeof(u16)) =
+				cpu_to_le16(IEEE80211_CHAN_OFDM |
+					     IEEE80211_CHAN_5GHZ);
+		else if (priv->ieee->mode == IEEE_B) /* 802.11b */
+			*(u16*)skb_put(dst, sizeof(u16)) =
+				cpu_to_le16(IEEE80211_CHAN_CCK |
+					     IEEE80211_CHAN_2GHZ);
+		else 		/* 802.11g */
+			*(u16*)skb_put(dst, sizeof(u16)) =
+				cpu_to_le16(IEEE80211_CHAN_OFDM |
+				 IEEE80211_CHAN_2GHZ);
+
+		rt_hdr->it_len = dst->len;
+
+		memcpy(skb_put(dst, len), src->data, len);
+
+		if (!ieee80211_rx(priv->prom_priv->ieee, dst, &dummystats))
+			dev_kfree_skb_any(dst);
+	}
+}
+
+
 static int ipw_net_hard_start_xmit(struct ieee80211_txb *txb,
 				   struct net_device *dev, int pri)
 {
@@ -10460,6 +10912,11 @@ static int ipw_net_hard_start_xmit(struc
 		goto fail_unlock;
 	}
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	if (rtap_iface && netif_running(priv->prom_net_dev))
+		ipw_handle_promiscuous_tx(priv, txb);
+#endif
+
 	ret = ipw_tx_skb(priv, txb, pri);
 	if (ret == NETDEV_TX_OK)
 		__ipw_led_activity_on(priv);
@@ -10478,6 +10935,9 @@ static struct net_device_stats *ipw_net_
 
 	priv->ieee->stats.tx_packets = priv->tx_packets;
 	priv->ieee->stats.rx_packets = priv->rx_packets;
+	priv->ieee->stats.rx_bytes = priv->rx_bytes;
+	priv->ieee->stats.tx_bytes = priv->tx_bytes;
+
 	return &priv->ieee->stats;
 }
 
@@ -10912,12 +11372,21 @@ static int ipw_config(struct ipw_priv *p
 			    |= CFG_BT_COEXISTENCE_OOB;
 	}
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	if (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {
+		priv->sys_config.accept_all_data_frames = 1;
+		priv->sys_config.accept_non_directed_frames = 1;
+		priv->sys_config.accept_all_mgmt_bcpr = 1;
+		priv->sys_config.accept_all_mgmt_frames = 1;
+	}
+#endif
+
 	if (priv->ieee->iw_mode == IW_MODE_ADHOC)
 		priv->sys_config.answer_broadcast_ssid_probe = 1;
 	else
 		priv->sys_config.answer_broadcast_ssid_probe = 0;
 
-	if (ipw_send_system_config(priv, &priv->sys_config))
+	if (ipw_send_system_config(priv))
 		goto error;
 
 	init_supported_rates(priv, &priv->rates);
@@ -11562,6 +12031,10 @@ static struct attribute *ipw_sysfs_entri
 	&dev_attr_led.attr,
 	&dev_attr_speed_scan.attr,
 	&dev_attr_net_stats.attr,
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	&dev_attr_rtap_iface.attr,
+	&dev_attr_rtap_filter.attr,
+#endif
 	NULL
 };
 
@@ -11570,6 +12043,109 @@ static struct attribute_group ipw_attrib
 	.attrs = ipw_sysfs_entries,
 };
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+static int ipw_prom_open(struct net_device *dev)
+{
+	struct ipw_prom_priv *prom_priv = ieee80211_priv(dev);
+	struct ipw_priv *priv = prom_priv->priv;
+
+	IPW_DEBUG_INFO("prom dev->open\n");
+	netif_carrier_off(dev);
+	netif_stop_queue(dev);
+
+	if (priv->ieee->iw_mode != IW_MODE_MONITOR) {
+		priv->sys_config.accept_all_data_frames = 1;
+		priv->sys_config.accept_non_directed_frames = 1;
+		priv->sys_config.accept_all_mgmt_bcpr = 1;
+		priv->sys_config.accept_all_mgmt_frames = 1;
+
+		ipw_send_system_config(priv);
+	}
+
+	return 0;
+}
+
+static int ipw_prom_stop(struct net_device *dev)
+{
+	struct ipw_prom_priv *prom_priv = ieee80211_priv(dev);
+	struct ipw_priv *priv = prom_priv->priv;
+
+	IPW_DEBUG_INFO("prom dev->stop\n");
+
+	if (priv->ieee->iw_mode != IW_MODE_MONITOR) {
+		priv->sys_config.accept_all_data_frames = 0;
+		priv->sys_config.accept_non_directed_frames = 0;
+		priv->sys_config.accept_all_mgmt_bcpr = 0;
+		priv->sys_config.accept_all_mgmt_frames = 0;
+
+		ipw_send_system_config(priv);
+	}
+
+	return 0;
+}
+
+static int ipw_prom_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	IPW_DEBUG_INFO("prom dev->xmit\n");
+	netif_stop_queue(dev);
+	return -EOPNOTSUPP;
+}
+
+static struct net_device_stats *ipw_prom_get_stats(struct net_device *dev)
+{
+	struct ipw_prom_priv *prom_priv = ieee80211_priv(dev);
+	return &prom_priv->ieee->stats;
+}
+
+static int ipw_prom_alloc(struct ipw_priv *priv)
+{
+	int rc = 0;
+
+	if (priv->prom_net_dev)
+		return -EPERM;
+
+	priv->prom_net_dev = alloc_ieee80211(sizeof(struct ipw_prom_priv));
+	if (priv->prom_net_dev == NULL)
+		return -ENOMEM;
+
+	priv->prom_priv = ieee80211_priv(priv->prom_net_dev);
+	priv->prom_priv->ieee = netdev_priv(priv->prom_net_dev);
+	priv->prom_priv->priv = priv;
+
+	strcpy(priv->prom_net_dev->name, "rtap%d");
+
+	priv->prom_net_dev->type = ARPHRD_IEEE80211_RADIOTAP;
+	priv->prom_net_dev->open = ipw_prom_open;
+	priv->prom_net_dev->stop = ipw_prom_stop;
+	priv->prom_net_dev->get_stats = ipw_prom_get_stats;
+	priv->prom_net_dev->hard_start_xmit = ipw_prom_hard_start_xmit;
+
+	priv->prom_priv->ieee->iw_mode = IW_MODE_MONITOR;
+
+	rc = register_netdev(priv->prom_net_dev);
+	if (rc) {
+		free_ieee80211(priv->prom_net_dev);
+		priv->prom_net_dev = NULL;
+		return rc;
+	}
+
+	return 0;
+}
+
+static void ipw_prom_free(struct ipw_priv *priv)
+{
+	if (!priv->prom_net_dev)
+		return;
+
+	unregister_netdev(priv->prom_net_dev);
+	free_ieee80211(priv->prom_net_dev);
+
+	priv->prom_net_dev = NULL;
+}
+
+#endif
+
+
 static int ipw_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	int err = 0;
@@ -11710,6 +12286,18 @@ static int ipw_pci_probe(struct pci_dev 
 		goto out_remove_sysfs;
 	}
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	if (rtap_iface) {
+	        err = ipw_prom_alloc(priv);
+		if (err) {
+			IPW_ERROR("Failed to register promiscuous network "
+				  "device (error %d).\n", err);
+			unregister_netdev(priv->net_dev);
+			goto out_remove_sysfs;
+		}
+	}
+#endif
+
 	printk(KERN_INFO DRV_NAME ": Detected geography %s (%d 802.11bg "
 	       "channels, %d 802.11a channels)\n",
 	       priv->ieee->geo.name, priv->ieee->geo.bg_channels,
@@ -11789,6 +12377,10 @@ static void ipw_pci_remove(struct pci_de
 		priv->error = NULL;
 	}
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	ipw_prom_free(priv);
+#endif
+
 	free_irq(pdev->irq, priv);
 	iounmap(priv->hw_base);
 	pci_release_regions(pdev);
@@ -11934,6 +12526,11 @@ MODULE_PARM_DESC(debug, "debug output ma
 module_param(channel, int, 0444);
 MODULE_PARM_DESC(channel, "channel to limit associate to (default 0 [ANY])");
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+module_param(rtap_iface, int, 0444);
+MODULE_PARM_DESC(rtap_iface, "create the rtap interface (1 - create, default 0)");
+#endif
+
 #ifdef CONFIG_IPW_QOS
 module_param(qos_enable, int, 0444);
 MODULE_PARM_DESC(qos_enable, "enable all QoS functionalitis");
diff -Nupr ipw2200-1.1.1/ipw2200.h ipw2200-1.1.1-rtap/ipw2200.h
--- ipw2200-1.1.1/ipw2200.h	2006-03-08 06:42:55.000000000 -0600
+++ ipw2200-1.1.1-rtap/ipw2200.h	2006-03-23 17:27:15.000000000 -0600
@@ -797,7 +797,7 @@ struct ipw_sys_config {
 	u8 bt_coexist_collision_thr;
 	u8 silence_threshold;
 	u8 accept_all_mgmt_bcpr;
-	u8 accept_all_mgtm_frames;
+	u8 accept_all_mgmt_frames;
 	u8 pass_noise_stats_to_host;
 	u8 reserved3;
 } __attribute__ ((packed));
@@ -1130,6 +1130,52 @@ struct ipw_fw_error {
 	u8 payload[0];
 } __attribute__ ((packed));
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+
+enum ipw_prom_filter {
+	IPW_PROM_CTL_HEADER_ONLY = (1 << 0),
+	IPW_PROM_MGMT_HEADER_ONLY = (1 << 1),
+	IPW_PROM_DATA_HEADER_ONLY = (1 << 2),
+	IPW_PROM_ALL_HEADER_ONLY = 0xf, /* bits 0..3 */
+	IPW_PROM_NO_TX = (1 << 4),
+	IPW_PROM_NO_RX = (1 << 5),
+	IPW_PROM_NO_CTL = (1 << 6),
+	IPW_PROM_NO_MGMT = (1 << 7),
+	IPW_PROM_NO_DATA = (1 << 8),
+};
+
+struct ipw_priv;
+struct ipw_prom_priv {
+	struct ipw_priv *priv;
+	struct ieee80211_device *ieee;
+	enum ipw_prom_filter filter;
+	int tx_packets;
+	int rx_packets;
+};
+#endif
+
+#if defined(CONFIG_IEEE80211_RADIOTAP) || defined(CONFIG_IPW2200_PROMISCUOUS)
+/* Magic struct that slots into the radiotap header -- no reason
+ * to build this manually element by element, we can write it much
+ * more efficiently than we can parse it. ORDER MATTERS HERE
+ *
+ * When sent to us via the simulated Rx interface in sysfs, the entire
+ * structure is provided regardless of any bits unset.
+ */
+struct ipw_rt_hdr {
+	struct ieee80211_radiotap_header rt_hdr;
+	u64 rt_tsf;      /* TSF */
+	u8 rt_flags;	/* radiotap packet flags */
+	u8 rt_rate;	/* rate in 500kb/s */
+	u16 rt_channel;	/* channel in mhz */
+	u16 rt_chbitmask;	/* channel bitfield */
+	s8 rt_dbmsignal;	/* signal in dbM, kluged to signed */
+	s8 rt_dbmnoise;
+	u8 rt_antenna;	/* antenna number */
+	u8 payload[0];  /* payload... */
+} __attribute__ ((packed));
+#endif
+
 struct ipw_priv {
 	/* ieee device used by generic ieee processing code */
 	struct ieee80211_device *ieee;
@@ -1141,6 +1187,12 @@ struct ipw_priv {
 	struct pci_dev *pci_dev;
 	struct net_device *net_dev;
 
+#ifdef CONFIG_IPW2200_PROMISCUOUS
+	/* Promiscuous mode */
+	struct ipw_prom_priv *prom_priv;
+	struct net_device *prom_net_dev;
+#endif
+
 	/* pci hardware address support */
 	void __iomem *hw_base;
 	unsigned long hw_len;
@@ -1226,8 +1278,10 @@ struct ipw_priv {
 
 	u32 missed_adhoc_beacons;
 	u32 missed_beacons;
-	u32 rx_packets;
-	u32 tx_packets;
+	unsigned long rx_packets;
+	unsigned long tx_packets;
+	unsigned long tx_bytes;
+	unsigned long rx_bytes;
 	u32 quality;
 
 	u8 speed_scan[MAX_SPEED_SCAN];
@@ -1318,6 +1372,29 @@ struct ipw_priv {
 
 /* debug macros */
 
+/* Debug and printf string expansion helpers for printing bitfields */
+#define BIT_FMT8 "%c%c%c%c-%c%c%c%c"
+#define BIT_FMT16 BIT_FMT8 ":" BIT_FMT8
+#define BIT_FMT32 BIT_FMT16 " " BIT_FMT16
+
+#define BITC(x,y) (((x>>y)&1)?'1':'0')
+#define BIT_ARG8(x) \
+BITC(x,7),BITC(x,6),BITC(x,5),BITC(x,4),\
+BITC(x,3),BITC(x,2),BITC(x,1),BITC(x,0)
+
+#define BIT_ARG16(x) \
+BITC(x,15),BITC(x,14),BITC(x,13),BITC(x,12),\
+BITC(x,11),BITC(x,10),BITC(x,9),BITC(x,8),\
+BIT_ARG8(x)
+
+#define BIT_ARG32(x) \
+BITC(x,31),BITC(x,30),BITC(x,29),BITC(x,28),\
+BITC(x,27),BITC(x,26),BITC(x,25),BITC(x,24),\
+BITC(x,23),BITC(x,22),BITC(x,21),BITC(x,20),\
+BITC(x,19),BITC(x,18),BITC(x,17),BITC(x,16),\
+BIT_ARG16(x)
+
+
 #ifdef CONFIG_IPW2200_DEBUG
 #define IPW_DEBUG(level, fmt, args...) \
 do { if (ipw_debug_level & (level)) \
diff -Nupr ipw2200-1.1.1/ipwstats.c ipw2200-1.1.1-rtap/ipwstats.c
--- ipw2200-1.1.1/ipwstats.c	1969-12-31 18:00:00.000000000 -0600
+++ ipw2200-1.1.1-rtap/ipwstats.c	2006-03-23 17:27:14.000000000 -0600
@@ -0,0 +1,752 @@
+/******************************************************************************
+
+  Copyright(c) 2006 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+  USA
+
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.
+
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR
+  97124-6497
+
+******************************************************************************/
+
+/******************************************************************************
+
+  To build:
+
+	% gcc -I/usr/src/linux/include -Wall -o ipwstats ipwstats.c
+
+  To run:
+
+	% ./ipwstats --help
+
+  TODO:
+  * Add ability to set the rtap_filter via sysfs from this program:
+     --filter    Lists the filter bitmask values
+     --filter=N  Sets the filter to N
+
+******************************************************************************/
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+
+#include <linux/rtnetlink.h>
+#include <linux/netlink.h>
+#include <linux/if_packet.h>
+#include <linux/if_ether.h>
+#include <linux/if_arp.h>
+#include <linux/if.h>
+#include <linux/llc.h>
+#include <linux/sockios.h>
+
+#include <netinet/in.h>
+
+#include <gtk/gtk.h>
+
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <math.h>
+#include <ctype.h>
+#include <dirent.h>
+
+typedef signed char s8;
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+typedef unsigned long long u64;
+typedef signed long long s64;
+
+#include <net/ieee80211_radiotap.h>
+
+#define WIDTH 640
+#define HEIGHT 400
+#define INTERVAL 250
+
+/*****************************************************************************
+ *
+ * IEEE 802.11 Declarations
+ *
+ * We define these here as including net/ieee80211.h has too many other
+ * typedef dependencies.  Also, depending on the net/ieee80211.h on the system,
+ * some of these types may not be defined.
+ *
+ */
+#define IEEE80211_MAC_LEN       6
+#define IEEE80211_3ADDR_LEN     24
+
+#define IEEE80211_FCTL_FTYPE	0x000c
+#define IEEE80211_FCTL_STYPE	0x00f0
+#define IEEE80211_FCTL_TODS	0x0100
+
+#define IEEE80211_FTYPE_MGMT		0x0000
+#define IEEE80211_FTYPE_CTL		0x0004
+#define IEEE80211_FTYPE_DATA		0x0008
+
+#define IEEE80211_STYPE_PROBE_RESP 0x0050
+#define IEEE80211_STYPE_BEACON	   0x0080
+#define IEEE80211_STYPE_DEAUTH     0x00C0
+
+struct ieee80211_hdr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 payload[0];
+} __attribute__ ((packed));
+
+struct ieee80211_hdr_3addr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[IEEE80211_MAC_LEN];
+	u8 addr2[IEEE80211_MAC_LEN];
+	u8 addr3[IEEE80211_MAC_LEN];
+	__le16 seq_ctl;
+	u8 payload[0];
+} __attribute__ ((packed));
+
+
+/* IEEE 802.11h Declarations */
+#define IEEE80211_STYPE_ACTION 0x00D0
+
+enum {
+	IEEE80211_IE_CSA = 37,
+};
+
+enum {
+	IEEE80211_ACTION_SPECTRUM_MGMT = 0,
+};
+
+enum {
+	IEEE80211_ACTION_CATEGORY_CHANNEL_SWITCH = 4,
+};
+
+struct ieee80211_channel_switch {
+	u8 id;
+	u8 len;
+	u8 mode;
+	u8 channel;
+	u8 count;
+} __attribute__ ((packed));
+
+struct ieee80211h_csa {
+	struct ieee80211_hdr_3addr header;
+	u8 category;
+	u8 action;
+	struct ieee80211_channel_switch channel_switch;
+} __attribute__ ((packed));
+
+struct ieee80211_deauth {
+	struct ieee80211_hdr_3addr header;
+	__le16 reason;
+} __attribute__ ((packed));
+
+/*****************************************************************************/
+
+
+#define VERSION "0.1"
+#define COPYRIGHT "Copyright (C) 2006, Intel Corporation."
+
+struct ipw_rt_hdr {
+	struct ieee80211_radiotap_header rt_hdr;
+	u64 rt_tsf;
+	u8 rt_flags;
+	u8 rt_rate;
+	u16 rt_channel;
+	u16 rt_chbitmask;
+	s8 rt_dbmsignal;
+	s8 rt_dbmnoise;
+	u8 rt_antenna;
+	u8 payload[0];
+} __attribute__ ((packed));
+
+/* 3945 Simulation Sysfs Interface declarations */
+
+#define SYSFS_DRIVER "/sys/class/net/eth1/device"
+
+struct priv {
+	char sysfs_path[PATH_MAX];
+	u8 ifname[IFNAMSIZ];
+	int ifindex;
+	u8 channel;
+
+	unsigned long rx_tot[WIDTH];
+	unsigned long rx_samp[WIDTH];
+	unsigned long tx_tot[WIDTH];
+	unsigned long tx_samp[WIDTH];
+	struct timeval start_time;
+	long signal;
+	long noise;
+	long rate;
+	long samples;
+	unsigned long long rx_bytes;
+	unsigned long long tx_bytes;
+
+	int set_quiet;
+	int set_channel;
+	int set_bss;
+	int set_dst;
+	int set_src;
+	int set_type;
+	int set_rate;
+	int set_ifindex;
+	int set_ifname;
+
+	GtkWidget* graph;
+};
+
+int usage(char *argv[], int ret)
+{
+	if (ret)
+		fprintf(stderr, "Invalid parameter %d: %s.\n\n",
+			ret, argv[ret]);
+
+	fprintf(stdout, "usage: ipwstats [--OPTION]\n"
+		"options:\n"
+		"  --channel\t\tFilter results to one channel (eg. 9)\n"
+		"  --iface\t\tInterface name (eg. rtap0) or index (eg. 12)\n"
+		"  --version\t\tDisplay version information\n"
+		"  --help\t\tView this help message\n");
+
+	return -ret;
+}
+
+enum {
+	PARAM_NONE = 0,
+	PARAM_VALUE = 1,
+};
+
+inline int param_check(const char *param, const char *value, int type)
+{
+	int len = strlen(value);
+	int comp = strncmp(param, value, len);
+
+	if (comp)
+		return 0;
+
+	if (type == PARAM_VALUE)	/* = */
+		return (param[len] != '=') ? -1 : len + 1;
+
+	/* no = */
+
+	return (param[len] != '\0') ? -1 : len;
+}
+
+int version()
+{
+	fprintf(stdout, "ipwstats - S/N vs. throughput statistics\n");
+	fprintf(stdout, "%s\n", COPYRIGHT);
+	fprintf(stdout, "version: "  VERSION  "\n");
+	return 0;
+}
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#define ETH_P_80211_RADIOTAP (ETH_P_80211_RAW + 1)
+#endif
+
+enum {
+	CSA = 0,
+	DEAUTH = 1,
+};
+
+static int inline ieee80211mhz2chan(u16 freq)
+{
+	if (freq == 2484)
+		return 14;
+	if (freq <= 2472)
+		return (freq - 2407) / 5;
+	return (freq / 5) - 1000;
+}
+
+#define ieee80211_is_probe_response(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT && \
+    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PROBE_RESP )
+
+#define ieee80211_is_management(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT)
+
+#define ieee80211_is_control(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL)
+
+#define ieee80211_is_data(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA)
+
+#define ieee80211_is_assoc_request(fc) \
+   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_ASSOC_REQ)
+
+#define ieee80211_is_reassoc_request(fc) \
+   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_REASSOC_REQ)
+
+static gboolean delete_event( GtkWidget *widget,
+                              GdkEvent  *event,
+                              gpointer   data )
+{
+    /* If you return FALSE in the "delete_event" signal handler,
+     * GTK will emit the "destroy" signal. Returning TRUE means
+     * you don't want the window to be destroyed.
+     * This is useful for popping up 'are you sure you want to quit?'
+     * type dialogs. */
+
+    g_print ("delete event occurred\n");
+
+    /* Change TRUE to FALSE and the main window will be destroyed with
+     * a "delete_event". */
+
+    return FALSE;
+}
+
+static GdkPixmap *pixmap = NULL;
+
+/* Another callback */
+static void destroy( GtkWidget *widget,
+                     gpointer   data )
+{
+    gtk_main_quit ();
+}
+
+u8 frame[3072];
+
+unsigned long msec_diff(struct timeval *start, struct timeval *stop)
+{
+	unsigned long delta = (stop->tv_sec - start->tv_sec) * 1000;
+	if (stop->tv_usec > start->tv_usec)
+		return delta + (stop->tv_usec - start->tv_usec) / 1000;
+	return delta - (start->tv_usec - stop->tv_usec) / 1000;
+}
+
+void data_available(gpointer data,
+		    gint source,
+		    GdkInputCondition condition)
+{
+	struct priv *priv = (void *)data;
+	u8 *p;
+	struct ieee80211_radiotap_header *rt_hdr;
+	struct ieee80211_hdr *hdr;
+	struct ipw_rt_hdr rt;
+	char *ftype;
+	int len;
+	int fd;
+	char buffer[16];
+	struct timeval now;
+	unsigned long rx, tx;
+	float signal, noise;
+	long rate, samples;
+	unsigned long msecs;
+	int x;
+	float tx_y, rx_y;
+	float ratio;
+
+	gettimeofday(&now, NULL);
+
+	len = recv(source, frame, sizeof(frame), MSG_TRUNC);
+	if (len == -1) {
+		fprintf(stderr, "recv failed: %s (%d)\n",
+			strerror(errno),
+			errno);
+		return;
+	}
+
+	if (len < sizeof(*rt_hdr)) {
+		fprintf(stderr, "Short packet received.\n");
+		return;
+	}
+
+	rt_hdr = (void *)frame;
+	p = (void *)frame;
+
+	/* Check radiotap header... */
+	if (rt_hdr->it_version != PKTHDR_RADIOTAP_VERSION) {
+		fprintf(stderr, "driver / app protocol version "
+			"mismatch (v%d vs. v%d).\n",
+			PKTHDR_RADIOTAP_VERSION, rt_hdr->it_version);
+		return;
+	}
+
+	/* Extract radiotap header information */
+	memset(&rt, 0, sizeof(rt));
+	memcpy(&rt.rt_hdr, rt_hdr, sizeof(rt.rt_hdr));
+	p += sizeof(rt.rt_hdr);
+
+	if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_TSFT))
+		p += sizeof(rt.rt_tsf);
+	if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_FLAGS)) {
+		rt.rt_flags = *(u8*)p;
+		p += sizeof(rt.rt_flags);
+	}
+	if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_RATE)) {
+		rt.rt_rate = *(u8*)p;
+		p += sizeof(rt.rt_rate);
+	}
+	if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_CHANNEL)) {
+		rt.rt_channel = *(u16*)p;
+		p += sizeof(rt.rt_channel);
+		rt.rt_channel = ieee80211mhz2chan(rt.rt_channel);
+		rt.rt_chbitmask = *(u16*)p;
+		p += sizeof(rt.rt_channel);
+	}
+	if (rt_hdr->it_present &
+	    (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL)) {
+		rt.rt_dbmsignal = *(u8*)p;
+		p += sizeof(rt.rt_dbmsignal);
+	}
+	if (rt_hdr->it_present &
+	    (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE)) {
+		rt.rt_dbmnoise = *(u8*)p;
+		p += sizeof(rt.rt_dbmnoise);
+	}
+	if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_ANTENNA)) {
+		rt.rt_antenna = *(u8*)p;
+		p += sizeof(rt.rt_antenna);
+	}
+
+	if (priv->set_channel && rt.rt_channel != priv->channel)
+		return;
+
+	hdr = (void *)p;
+	if (ieee80211_is_management(hdr->frame_ctl))
+		ftype = "MGMT";
+	else if (ieee80211_is_control(hdr->frame_ctl))
+		ftype = "CTRL";
+	else if (ieee80211_is_data(hdr->frame_ctl))
+		ftype = "DATA";
+	else
+		ftype = "UNKN";
+
+	if (!ieee80211_is_data(hdr->frame_ctl))
+		return;
+
+	/* Drop our Tx'd packets (no signal reported) */
+	if (rt.rt_dbmsignal == 0)
+		return;
+
+	priv->signal += rt.rt_dbmsignal;
+	priv->noise += rt.rt_dbmnoise;
+	priv->rate += rt.rt_rate;
+	priv->samples++;
+
+	if (!priv->start_time.tv_usec) {
+		gettimeofday(&priv->start_time, NULL);
+
+		fd = open("/sys/class/net/eth1/statistics/rx_bytes", O_RDONLY);
+		len = read(fd, buffer, sizeof(buffer));
+		buffer[len] = '\0';
+		priv->rx_bytes = strtoll(buffer, NULL, 0);
+		close(fd);
+
+		fd = open("/sys/class/net/eth1/statistics/tx_bytes", O_RDONLY);
+		len = read(fd, buffer, sizeof(buffer));
+		buffer[len] = '\0';
+		priv->tx_bytes = strtoll(buffer, NULL, 0);
+		close(fd);
+		return;
+	}
+
+	msecs = msec_diff(&priv->start_time, &now);
+	if (msecs >= INTERVAL) {
+		unsigned long long tmp;
+
+		fd = open("/sys/class/net/eth1/statistics/rx_bytes", O_RDONLY);
+		len = read(fd, buffer, sizeof(buffer));
+		buffer[len] = '\0';
+		tmp = strtoll(buffer, NULL, 0);
+		rx = tmp - priv->rx_bytes;
+		priv->rx_bytes = tmp;
+		close(fd);
+
+		fd = open("/sys/class/net/eth1/statistics/tx_bytes", O_RDONLY);
+		len = read(fd, buffer, sizeof(buffer));
+		buffer[len] = '\0';
+		tmp = strtoll(buffer, NULL, 0);
+		tx = tmp - priv->tx_bytes;
+		priv->tx_bytes = tmp;
+		close(fd);
+
+		signal = (float)priv->signal / priv->samples; 
+		noise = (float)priv->noise / priv->samples; 
+		rate = priv->rate / priv->samples;
+		samples = priv->samples;
+
+		priv->signal = 0;
+		priv->noise = 0;
+		priv->rate = 0;
+		priv->samples = 0;
+
+		ratio = (msecs * 1000.0) / (INTERVAL * INTERVAL);
+		tx = tx * ratio;
+		rx = rx * ratio;
+
+		if (!priv->set_quiet)
+			fprintf(stdout,
+				"%s: S/N =%4.0f/%4.0fdBm, rate = %ld%sMbps, "
+				"tx = %4.0fKbps, rx = %4.0fKbps\n",
+				ftype, signal, noise, rate >> 1,
+				(rate & 1) ? ".5" : "  ",
+				tx / 1024.0, rx / 1024.0);
+
+		priv->start_time = now;
+
+		if (signal > -10)
+			signal = -10;
+		if (signal < -100)
+			signal = -100;
+		signal = signal * 100.0 / 90.0;
+		x = (int)((float)(WIDTH/-100.0) * signal);
+
+		tx_y = (float)HEIGHT - (float)HEIGHT * tx / 3500000.0;
+		rx_y = (float)HEIGHT - (float)HEIGHT * rx / 3500000.0;
+
+
+		/* RX */
+
+		gdk_draw_point(pixmap, priv->graph->style->fg_gc[2], x, rx_y);
+		gtk_widget_queue_draw_area(priv->graph, x, rx_y, 1, 1);
+
+		if (priv->rx_samp[x]) {
+		gdk_draw_point(pixmap, priv->graph->style->fg_gc[2], x,
+			       priv->rx_tot[x] / priv->rx_samp[x]);
+		gtk_widget_queue_draw_area(priv->graph, x,
+					   priv->rx_tot[x] / priv->rx_samp[x],
+					   1, 1);
+		}
+
+		priv->rx_tot[x]+=rx_y;
+		priv->rx_samp[x]++;
+
+		gdk_draw_point(pixmap, priv->graph->style->black_gc, x,
+			       priv->rx_tot[x] / priv->rx_samp[x]);
+		gtk_widget_queue_draw_area(priv->graph, x,
+					   priv->rx_tot[x] / priv->rx_samp[x],
+					   1, 1);
+
+
+		/* TX */
+
+		gdk_draw_point(pixmap, priv->graph->style->fg_gc[4], x, tx_y);
+		gtk_widget_queue_draw_area(priv->graph, x, tx_y, 1, 1);
+
+		if (priv->tx_samp[x]) {
+		gdk_draw_point(pixmap, priv->graph->style->fg_gc[4], x,
+			       priv->tx_tot[x] / priv->tx_samp[x]);
+		gtk_widget_queue_draw_area(priv->graph, x,
+					   priv->tx_tot[x] / priv->tx_samp[x],
+					   1, 1);
+		}
+
+		priv->tx_tot[x] += tx_y;
+		priv->tx_samp[x]++;
+
+		gdk_draw_point(pixmap, priv->graph->style->black_gc, x,
+			       priv->tx_tot[x] / priv->tx_samp[x]);
+		gtk_widget_queue_draw_area(priv->graph, x,
+					   priv->tx_tot[x] / priv->tx_samp[x],
+					   1, 1);
+	}
+}
+
+
+static gboolean configure_event(GtkWidget *widget, GdkEventConfigure *event)
+{
+	if (pixmap)
+		g_object_unref(pixmap);
+	pixmap = gdk_pixmap_new(widget->window,
+				widget->allocation.width,
+				widget->allocation.height,
+				-1);
+	gdk_draw_rectangle(pixmap,
+			   widget->style->white_gc,
+			   TRUE, 0, 0,
+			   widget->allocation.width,
+			   widget->allocation.height);
+	return TRUE;
+}
+
+static gboolean expose_event(GtkWidget *widget, GdkEventConfigure *event)
+{
+	gdk_draw_drawable(widget->window,
+			  widget->style->fg_gc[GTK_WIDGET_STATE(widget)],
+			  pixmap,
+			  event->x, event->y,
+			  event->x, event->y,
+			  event->width, event->height);
+	return FALSE;
+}
+
+int main(int argc, char *argv[])
+{
+	struct priv priv;
+	int pos, i = 0;
+	struct sockaddr_ll sll_addr = {
+		.sll_family = AF_PACKET,
+		.sll_ifindex = -1,
+		.sll_protocol = htons(ETH_P_80211_RAW),
+		.sll_hatype = ARPHRD_IEEE80211_RADIOTAP,
+		.sll_pkttype = PACKET_OTHERHOST,
+	};
+	struct ifreq ifr = {
+		.ifr_name = "rtap0",
+	};
+	int err, err_len = sizeof(err);
+	int sock;
+
+	/* GtkWidget is the storage type for widgets */
+	GtkWidget *window;
+
+	/* This is called in all GTK applications. Arguments are parsed
+	 * from the command line and are returned to the application. */
+	gtk_init (&argc, &argv);
+
+	memset(&priv, 0, sizeof(priv));
+	while (i < argc - 1) {
+		i++;
+
+		if (argv[i][0] != '-' || argv[i][1] != '-')
+			return usage(argv, i);
+
+		pos = param_check(&argv[i][2], "iface", PARAM_VALUE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos) {
+			priv.ifindex = strtol(&argv[i][2 + pos], NULL, 0);
+			if (priv.ifindex == 0) {
+				priv.set_ifname = 1;
+				strncpy(priv.ifname, &argv[i][2 + pos],
+					sizeof(priv.ifname));
+			} else
+				priv.set_ifindex = 1;
+
+			continue;
+		}
+
+		pos = param_check(&argv[i][2], "channel", PARAM_VALUE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos) {
+			priv.channel = strtol(&argv[i][2 + pos], NULL, 0);
+			priv.set_channel = 1;
+			continue;
+		}
+
+		pos = param_check(&argv[i][2], "quiet", PARAM_NONE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos) {
+			priv.set_quiet = 1;
+			continue;
+		}
+
+		pos = param_check(&argv[i][2], "help", PARAM_NONE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos)
+			return usage(argv, 0);
+
+		pos = param_check(&argv[i][2], "version", PARAM_NONE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos)
+			return version();
+
+		return usage(argv, i);
+	}
+
+	if (priv.set_ifindex)
+		ifr.ifr_ifindex = priv.ifindex;
+	else if (priv.set_ifname)
+		strncpy(ifr.ifr_name, priv.ifname, sizeof(ifr.ifr_name));
+
+	sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_80211_RAW));
+	if (sock == -1) {
+		fprintf(stderr, "Error: socket() failed reason (%d): %s\n",
+			errno, strerror(errno));
+		return 1;
+	}
+
+	/* Figure out the index (if given name) or name (if given an index)
+	 * of the target interface */
+	if (!priv.set_ifindex) {
+		if (ioctl(sock, SIOCGIFINDEX, &ifr) == -1) {
+			fprintf(stderr, "Error: ioctl() failed reason (%d): "
+				"%s\n", errno, strerror(errno));
+			return 1;
+		}
+	} else if (priv.set_ifname) {
+		/* User provided device index */
+		if (ioctl(sock, SIOCGIFNAME, &ifr) == -1) {
+			fprintf(stderr, "Error: ioctl() failed reason (%d): "
+				"%s\n", errno, strerror(errno));
+			return 1;
+		}
+	}
+
+	sll_addr.sll_ifindex = ifr.ifr_ifindex;
+
+	fprintf(stdout, "using: %s (%d)\n", ifr.ifr_name, ifr.ifr_ifindex);
+
+	/* Bind to the appropiate interface */
+	if (bind(sock, (struct sockaddr *)&sll_addr, sizeof(sll_addr))) {
+		fprintf(stderr, "Error: bind() failed reason (%d): %s\n",
+			errno, strerror(errno));
+		return 1;
+	}
+
+	/* Verify no errors on socket */
+	if (getsockopt(sock, SOL_SOCKET, SO_ERROR, &err, &err_len)) {
+		fprintf(stderr, "Error: getsockopt() reason (%d): %s\n",
+			errno, strerror(errno));
+		return 1;
+	}
+
+	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+	g_signal_connect (G_OBJECT (window), "delete_event",
+			  G_CALLBACK (delete_event), NULL);
+	g_signal_connect (G_OBJECT (window), "destroy",
+			  G_CALLBACK (destroy), NULL);
+	gtk_container_set_border_width (GTK_CONTAINER (window), 10);
+
+	priv.graph = gtk_drawing_area_new();
+
+	g_signal_connect (G_OBJECT (priv.graph), "expose_event",
+			  G_CALLBACK (expose_event), NULL);
+	g_signal_connect (G_OBJECT (priv.graph), "configure_event",
+			  G_CALLBACK (configure_event), NULL);
+
+	gtk_widget_set_size_request(priv.graph, WIDTH, HEIGHT);
+
+	gtk_container_add (GTK_CONTAINER(window), priv.graph);
+
+	gdk_input_add(sock, GDK_INPUT_READ, data_available, &priv);
+
+	gtk_widget_show(priv.graph);
+	gtk_widget_show(window);
+
+	gtk_main ();
+
+	close(sock);
+
+	return 0;
+}
diff -Nupr ipw2200-1.1.1/ipwstats.cc ipw2200-1.1.1-rtap/ipwstats.cc
--- ipw2200-1.1.1/ipwstats.cc	1969-12-31 18:00:00.000000000 -0600
+++ ipw2200-1.1.1-rtap/ipwstats.cc	2006-03-22 15:12:03.000000000 -0600
@@ -0,0 +1,571 @@
+/******************************************************************************
+
+  Copyright(c) 2006 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, 
+  USA
+
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.
+
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 
+  97124-6497
+
+******************************************************************************/
+
+/******************************************************************************
+
+  To build:
+
+	% gcc -I/usr/src/linux/include -Wall -o ipwstats ipwstats.c
+
+  To run:
+
+	% ./ipwstats --help
+
+  TODO:
+  * Add ability to set the rtap_filter via sysfs from this program:
+     --filter    Lists the filter bitmask values
+     --filter=N  Sets the filter to N
+
+******************************************************************************/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+
+#include <linux/rtnetlink.h>
+#include <linux/netlink.h>
+#include <linux/if_packet.h>
+#include <linux/if_ether.h>
+#include <linux/if_arp.h>
+#include <linux/if.h>
+#include <linux/llc.h>
+#include <linux/sockios.h>
+
+#include <netinet/in.h>
+
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <math.h>
+#include <ctype.h>
+#include <dirent.h>
+
+typedef signed char s8;
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+typedef unsigned long long u64;
+typedef signed long long s64;
+
+#include <net/ieee80211_radiotap.h>
+
+/*****************************************************************************
+ *
+ * IEEE 802.11 Declarations 
+ *
+ * We define these here as including net/ieee80211.h has too many other
+ * typedef dependencies.  Also, depending on the net/ieee80211.h on the system,
+ * some of these types may not be defined.
+ *
+ */
+#define IEEE80211_MAC_LEN       6
+#define IEEE80211_3ADDR_LEN     24
+
+#define IEEE80211_FCTL_FTYPE	0x000c
+#define IEEE80211_FCTL_STYPE	0x00f0
+#define IEEE80211_FCTL_TODS	0x0100
+
+#define IEEE80211_FTYPE_MGMT		0x0000
+#define IEEE80211_FTYPE_CTL		0x0004
+#define IEEE80211_FTYPE_DATA		0x0008
+
+#define IEEE80211_STYPE_PROBE_RESP 0x0050
+#define IEEE80211_STYPE_BEACON	   0x0080
+#define IEEE80211_STYPE_DEAUTH     0x00C0
+
+struct ieee80211_hdr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 payload[0];
+} __attribute__ ((packed));
+
+struct ieee80211_hdr_3addr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[IEEE80211_MAC_LEN];
+	u8 addr2[IEEE80211_MAC_LEN];
+	u8 addr3[IEEE80211_MAC_LEN];
+	__le16 seq_ctl;
+	u8 payload[0];
+} __attribute__ ((packed));
+
+
+/* IEEE 802.11h Declarations */
+#define IEEE80211_STYPE_ACTION 0x00D0
+
+enum {
+	IEEE80211_IE_CSA = 37,
+};
+
+enum {
+	IEEE80211_ACTION_SPECTRUM_MGMT = 0,
+};
+
+enum {
+	IEEE80211_ACTION_CATEGORY_CHANNEL_SWITCH = 4,
+};
+
+struct ieee80211_channel_switch {
+	u8 id;
+	u8 len;
+	u8 mode;
+	u8 channel;
+	u8 count;
+} __attribute__ ((packed));
+
+struct ieee80211h_csa {
+	struct ieee80211_hdr_3addr header;
+	u8 category;
+	u8 action;
+	struct ieee80211_channel_switch channel_switch;
+} __attribute__ ((packed));
+
+struct ieee80211_deauth {
+	struct ieee80211_hdr_3addr header;
+	__le16 reason;
+} __attribute__ ((packed));
+
+/*****************************************************************************/
+
+
+#define VERSION "0.1"
+#define COPYRIGHT "Copyright (C) 2006, Intel Corporation."
+
+struct ipw_rt_hdr {
+	struct ieee80211_radiotap_header rt_hdr;
+	u64 rt_tsf;
+	u8 rt_flags;
+	u8 rt_rate;
+	u16 rt_channel;
+	u16 rt_chbitmask;
+	s8 rt_dbmsignal;
+	s8 rt_dbmnoise;
+	u8 rt_antenna;
+	u8 payload[0];
+} __attribute__ ((packed));
+
+/* 3945 Simulation Sysfs Interface declarations */
+
+#define SYSFS_DRIVER "/sys/class/net/eth1/device"
+
+struct priv {
+	char sysfs_path[PATH_MAX];
+	u8 ifname[IFNAMSIZ];
+	int ifindex;
+	u8 channel;
+
+	int set_channel;
+	int set_bss;
+	int set_dst;
+	int set_src;
+	int set_type;
+	int set_rate;
+	int set_ifindex;
+	int set_ifname;
+};
+
+int usage(char *argv[], int ret)
+{
+	if (ret)
+		fprintf(stderr, "Invalid parameter %d: %s.\n\n",
+			ret, argv[ret]);
+
+	fprintf(stdout, "usage: ipwstats [--OPTION]\n"
+		"options:\n"
+		"  --channel\t\tFilter results to one channel (eg. 9)\n"
+		"  --iface\t\tInterface name (eg. rtap0) or index (eg. 12)\n"
+		"  --version\t\tDisplay version information\n"
+		"  --help\t\tView this help message\n");
+
+	return -ret;
+}
+
+enum {
+	PARAM_NONE = 0,
+	PARAM_VALUE = 1,
+};
+
+inline int param_check(const char *param, const char *value, int type)
+{
+	int len = strlen(value);
+	int comp = strncmp(param, value, len);
+
+	if (comp)
+		return 0;
+
+	if (type == PARAM_VALUE)	/* = */
+		return (param[len] != '=') ? -1 : len + 1;
+
+	/* no = */
+
+	return (param[len] != '\0') ? -1 : len;
+}
+
+int version()
+{
+	fprintf(stdout, "ipwstats - S/N vs. throughput statistics\n");
+	fprintf(stdout, "%s\n", COPYRIGHT);
+	fprintf(stdout, "version: "  VERSION  "\n");
+	return 0;
+}
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#define ETH_P_80211_RADIOTAP (ETH_P_80211_RAW + 1)
+#endif
+
+enum {
+	CSA = 0,
+	DEAUTH = 1,
+};
+
+static int inline ieee80211mhz2chan(u16 freq) 
+{
+	if (freq == 2484)
+		return 14;
+	if (freq <= 2472)
+		return (freq - 2407) / 5;
+	return (freq / 5) - 1000;
+}
+
+#define ieee80211_is_probe_response(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT && \
+    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PROBE_RESP )
+
+#define ieee80211_is_management(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT)
+
+#define ieee80211_is_control(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL)
+
+#define ieee80211_is_data(fc) \
+   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA)
+
+#define ieee80211_is_assoc_request(fc) \
+   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_ASSOC_REQ)
+
+#define ieee80211_is_reassoc_request(fc) \
+   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_REASSOC_REQ)
+
+
+
+#include <gtkmm/drawingarea.h>
+#include <gtkmm/main.h>
+#include <gtkmm/window.h>
+#include <cariomm/context.h>
+class MyArea : public Gtk::DrawingArea
+{
+ public:
+	MyArea();
+	virtual ~MyArea();
+
+ protected:
+	//Override default signal handler:
+	virtual bool on_expose_event(GdkEventExpose* event);
+};
+
+MyArea::MyArea()
+{
+}
+
+MyArea::~MyArea()
+{
+}
+
+bool MyArea::on_expose_event(GdkEventExpose* event)
+{
+	// This is where we draw on the window
+	Glib::RefPtr<Gdk::Window> window = get_window();
+	if(window)
+	{
+		Gtk::Allocation allocation = get_allocation();
+		const int width = allocation.get_width();
+		const int height = allocation.get_height();
+
+		// coordinates for the center of the window
+		int xc, yc;
+		xc = width / 2;
+		yc = height / 2;
+
+		Cairo::RefPtr<Cairo::Context> cr = 
+			window->create_cairo_context();
+		cr->set_line_width(10.0);
+
+		// clip to the area indicated by the expose event so 
+		// that we only redraw the portion of the window that
+		// needs to be redrawn
+		cr->rectangle(event->area.x, event->area.y,
+			      event->area.width, event->area.height);
+		cr->clip();
+
+		// draw red lines out from the center of the window
+		cr->set_source_rgb(0.8, 0.0, 0.0);
+		cr->move_to(0, 0);
+		cr->line_to(xc, yc);
+		cr->line_to(0, height);
+		cr->move_to(xc, yc);
+		cr->line_to(width, yc);
+		cr->stroke();
+	}
+
+	return true;
+}
+
+int main(int argc, char *argv[])
+{
+	struct priv priv;
+	int pos, i = 0;
+	u8 frame[3072];
+	u8 *p;
+	struct ieee80211_radiotap_header *rt_hdr;
+	struct ieee80211_hdr *hdr;
+	struct ipw_rt_hdr rt;
+	char *ftype;
+	struct sockaddr_ll sll_addr = {
+		.sll_family = AF_PACKET,
+		.sll_ifindex = -1,
+		.sll_protocol = htons(ETH_P_80211_RAW),
+		.sll_hatype = ARPHRD_IEEE80211_RADIOTAP,
+		.sll_pkttype = PACKET_OTHERHOST,
+	};
+	struct ifreq ifr = {
+		.ifr_name = "rtap0",
+	};
+	int err, err_len;
+
+	int sock;
+  
+	Gtk::Main kit(argc, argv);
+
+	Gtk::Window win;
+	win.set_title("DrawingArea");
+	
+	MyArea area;
+	win.add(area);
+	area.show();
+
+	memset(&priv, 0, sizeof(priv));
+	while (i < argc - 1) {
+		i++;
+	  
+		if (argv[i][0] != '-' || argv[i][1] != '-')
+			return usage(argv, i);
+
+		pos = param_check(&argv[i][2], "iface", PARAM_VALUE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos) {
+			priv.ifindex = strtol(&argv[i][2 + pos], NULL, 0);
+			if (priv.ifindex == 0) {
+				priv.set_ifname = 1;
+				strncpy(priv.ifname, &argv[i][2 + pos], 
+					sizeof(priv.ifname));
+			} else
+				priv.set_ifindex = 1;
+
+			continue;
+		}
+
+		pos = param_check(&argv[i][2], "channel", PARAM_VALUE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos) {
+			priv.channel = strtol(&argv[i][2 + pos], NULL, 0);
+			priv.set_channel = 1;
+			continue;
+		}
+
+		pos = param_check(&argv[i][2], "help", PARAM_NONE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos)
+			return usage(argv, 0);
+
+		pos = param_check(&argv[i][2], "version", PARAM_NONE);
+		if (pos < 0)
+			return usage(argv, i);
+		if (pos)
+			return version();
+
+		return usage(argv, i);
+	}
+
+	if (priv.set_ifindex) 
+		ifr.ifr_ifindex = priv.ifindex;
+	else if (priv.set_ifname)
+		strncpy(ifr.ifr_name, priv.ifname, sizeof(ifr.ifr_name));
+
+	sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_80211_RAW));
+	if (sock == -1) {
+		fprintf(stderr, "Error: socket() failed reason (%d): %s\n",
+			errno, strerror(errno));
+		return 1;
+	}
+
+	/* Figure out the index (if given name) or name (if given an index)
+	 * of the target interface */
+	if (!priv.set_ifindex) {
+		if (ioctl(sock, SIOCGIFINDEX, &ifr) == -1) {
+			fprintf(stderr, "Error: ioctl() failed reason (%d): "
+				"%s\n", errno, strerror(errno));
+			return 1;
+		}
+	} else if (priv.set_ifname) {
+		/* User provided device index */
+		if (ioctl(sock, SIOCGIFNAME, &ifr) == -1) {
+			fprintf(stderr, "Error: ioctl() failed reason (%d): "
+				"%s\n", errno, strerror(errno));
+			return 1;
+		}
+	}
+
+	sll_addr.sll_ifindex = ifr.ifr_ifindex;
+
+	fprintf(stdout, "using: %s (%d)\n", ifr.ifr_name, ifr.ifr_ifindex);
+
+	/* Bind to the appropiate interface */
+	if (bind(sock, (struct sockaddr *)&sll_addr, sizeof(sll_addr))) {
+		fprintf(stderr, "Error: bind() failed reason (%d): %s\n",
+			errno, strerror(errno));
+		return 1;
+	}
+
+	/* Verify no errors on socket */
+	if (getsockopt(sock, SOL_SOCKET, SO_ERROR, &err, &err_len)) {
+		fprintf(stderr, "Error: getsockopt() reason (%d): %s\n",
+			errno, strerror(errno));
+		return 1;
+	}
+	
+	Gtk::Main::run(win);
+	
+	while (1) { 
+/*
+		err = poll(5000, sock);
+		if (err == -1) {
+			fprintf(stderr, "poll: failed %d: %s\n",
+				errno, strerror(errno));
+			break;
+		}
+*/
+    
+		err = recv(sock, frame, sizeof(frame), MSG_TRUNC);
+		if (err == -1) {
+			fprintf(stderr, "recv failed: %s (%d)\n", 
+				strerror(errno),
+				errno);
+			err = -errno;
+			close(sock);
+			return err;
+		}
+    
+		if (err < sizeof(*rt_hdr)) {
+			fprintf(stderr, "Short packet received.\n");
+			continue;
+		}
+
+		rt_hdr = (void *)frame;
+		p = (void *)frame;
+
+		/* Check radiotap header... */
+		if (rt_hdr->it_version != PKTHDR_RADIOTAP_VERSION) {
+			fprintf(stderr, "driver / app protocol version "
+				"mismatch (v%d vs. v%d).\n",
+				PKTHDR_RADIOTAP_VERSION, rt_hdr->it_version);
+			continue;
+		}
+
+		/* Extract radiotap header information */
+		memset(&rt, 0, sizeof(rt));
+		memcpy(&rt.rt_hdr, rt_hdr, sizeof(rt.rt_hdr));
+		p += sizeof(rt.rt_hdr);
+
+		if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_TSFT))
+			p += sizeof(rt.rt_tsf);
+		if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_FLAGS)) {
+			rt.rt_flags = *(u8*)p;
+			p += sizeof(rt.rt_flags);
+		}
+		if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_RATE)) {
+			rt.rt_rate = *(u8*)p;
+			p += sizeof(rt.rt_rate);
+		}
+		if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_CHANNEL)) {
+			rt.rt_channel = *(u16*)p;
+			p += sizeof(rt.rt_channel);
+			rt.rt_channel = ieee80211mhz2chan(rt.rt_channel);
+			rt.rt_chbitmask = *(u16*)p;
+			p += sizeof(rt.rt_channel);
+		}
+		if (rt_hdr->it_present & 
+		    (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL)) {
+			rt.rt_dbmsignal = *(u8*)p;
+			p += sizeof(rt.rt_dbmsignal);
+		}
+		if (rt_hdr->it_present & 
+		    (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE)) {
+			rt.rt_dbmnoise = *(u8*)p;
+			p += sizeof(rt.rt_dbmnoise);
+		}
+		if (rt_hdr->it_present & (1 << IEEE80211_RADIOTAP_ANTENNA)) {
+			rt.rt_antenna = *(u8*)p;
+			p += sizeof(rt.rt_antenna);
+		}
+
+		if (priv.set_channel && rt.rt_channel != priv.channel)
+			continue;
+
+		hdr = (void *)p;
+		if (ieee80211_is_management(hdr->frame_ctl))
+			ftype = "MGMT";
+		else if (ieee80211_is_control(hdr->frame_ctl))
+			ftype = "CTRL";
+		else if (ieee80211_is_data(hdr->frame_ctl))
+			ftype = "DATA";
+		else
+			ftype = "UNKN";
+    
+		fprintf(stdout, 
+			"%s: Ch.%3d S/N =%4d/%4ddBm, rate = %d%sMbps\n", 
+			ftype, rt.rt_channel,
+			rt.rt_dbmsignal, rt.rt_dbmnoise, 
+			rt.rt_rate >> 1, (rt.rt_rate & 1) ? ".5" : "");
+	}
+
+	close(sock);
+  
+	return 0;
+}
